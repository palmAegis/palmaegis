<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Forum | Palm Aegis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="css/homepage.css">
    <link rel="stylesheet" href="css/sidebar.css">
    <link rel="stylesheet" href="css/forumtest.css">
</head>
<body>
    <div class="dashboard-container">
        <div id="sidebarPlaceholder"></div>
        <script src="js/sidebar-loader.js"></script>

        <main class="main-content">
            <div class="top-header">
                <div class="header-left">
                    <h1>Community Forum</h1>
                </div>
                <div class="search-box">
                    <i class="fas fa-search"></i>
                    <input type="text" placeholder="Search discussions..." id="searchInput">
                </div>
            </div>

            <div class="container">
                <div class="page-header">
                    <h2 class="page-title">Palm Aegis Community</h2>
                    <div class="page-actions">
                        <button class="btn btn-secondary" id="filterBtn">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                        <button class="btn btn-primary" id="createPostBtn">
                            <i class="fas fa-plus"></i> Create Post
                        </button>
                    </div>
                </div>

                <!-- Tab Navigation -->
                <div class="forum-tabs">
                    <button class="tab-btn active" data-category="all">All Discussions</button>
                    <button class="tab-btn" data-category="diseases">Diseases</button>
                    <button class="tab-btn" data-category="treatments">Treatments</button>
                    <button class="tab-btn" data-category="general">General Farming</button>
                </div>

                <div class="posts-container" id="postsContainer">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading discussions...</p>
                    </div>
                </div>

                <!-- Post Details/Reply Section -->
                <div class="post-details" id="postDetails" style="display: none;">
                    <div class="details-header">
                        <h2 class="details-title" id="detailsTitle">Discussion Details</h2>
                        <div>
                            <button class="btn btn-secondary" id="closeDetailsBtn">
                                <i class="fas fa-arrow-left"></i> Back to Forum
                            </button>
                        </div>
                    </div>
                    <div class="post-content" id="postContent">
                        <!-- Post content will be populated here -->
                    </div>
                    <div class="replies-container" id="repliesContainer">
                        <!-- Replies will be populated here -->
                    </div>
                    <div class="reply-form">
                        <h3>Post a Reply</h3>
                        <textarea id="replyText" placeholder="Type your reply here..."></textarea>
                        <div class="tag-experts">
                            <label>Tag Experts (Optional):</label>
                            <select id="expertSelect" multiple>
                                <!-- Experts will be populated here -->
                            </select>
                        </div>
                        <button class="btn btn-primary" id="submitReplyBtn">Post Reply</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Create Post Modal -->
    <div class="modal" id="createPostModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create New Post</h2>
                <button class="close-modal" id="closeCreateModalBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="postTitle" placeholder="Enter a title for your post">
                </div>
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <select class="form-select" id="postCategory">
                        <option value="diseases">Diseases</option>
                        <option value="treatments">Treatments</option>
                        <option value="general">General Farming</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Content</label>
                    <textarea class="form-textarea" id="postContentInput" placeholder="Describe your question or topic..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Tag Experts (Optional)</label>
                    <select class="form-select" id="postExpertTags" multiple>
                        <!-- Experts will be populated here -->
                    </select>
                    <small>Hold Ctrl/Cmd to select multiple experts</small>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-outline" id="cancelPostBtn">Cancel</button>
                <button class="btn btn-primary" id="submitPostBtn">Create Post</button>
            </div>
        </div>
    </div>

    <!-- Filter Modal -->
    <div class="modal" id="filterModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Filter Discussions</h2>
                <button class="close-modal" id="closeFilterBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="filter-options">
                    <div class="filter-group">
                        <label class="filter-label">Category</label>
                        <select class="filter-select" id="categoryFilter">
                            <option value="all">All Categories</option>
                            <option value="diseases">Diseases</option>
                            <option value="treatments">Treatments</option>
                            <option value="general">General Farming</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Sort By</label>
                        <select class="filter-select" id="sortFilter">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="most-votes">Most Votes</option>
                            <option value="most-replies">Most Replies</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Date Range</label>
                        <div class="date-range">
                            <input type="date" class="filter-input" id="dateFrom">
                            <span>to</span>
                            <input type="date" class="filter-input" id="dateTo">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-outline" id="clearFiltersBtn">Clear Filters</button>
                <button class="btn btn-primary" id="applyFiltersBtn">Apply Filters</button>
            </div>
        </div>
    </div>

    <!-- Edit Post Modal -->
    <div class="modal" id="editPostModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Edit Post</h2>
                <button class="close-modal" id="closeEditModalBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="editPostTitle">
                </div>
                <div class="form-group">
                    <label class="form-label">Content</label>
                    <textarea class="form-textarea" id="editPostContent"></textarea>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-outline" id="cancelEditBtn">Cancel</button>
                <button class="btn btn-primary" id="saveEditBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js';
    import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js'; 
    import { getFirestore, doc, getDoc, collection, getDocs, addDoc, updateDoc, deleteDoc, query, where, orderBy, onSnapshot, serverTimestamp, arrayUnion, arrayRemove } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js';

    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyAf-wtZpl8wVjCymdLlC-YGlv7xn0yEMMU",
        authDomain: "palmaegis-setup.firebaseapp.com",
        projectId: "palmaegis-setup",
        storageBucket: "palmaegis-setup.firebasestorage.app",
        messagingSenderId: "445887502374",
        appId: "1:445887502374:web:a5f6ecaa90b88447626ee7"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Global variables
    let currentUser = null;
    let currentCategory = 'all';
    let currentFilters = {
        category: 'all',
        sort: 'newest',
        dateFrom: '',
        dateTo: ''
    };
    let allPosts = [];
    let currentPostId = null;
    let expertsList = [];

    // Check authentication state
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            console.log('User is signed in:', user.email);
            window.currentUser = user;
            currentUser = {
                uid: user.uid,
                email: user.email,
                displayName: user.displayName || user.email.split('@')[0]
            };
            
            try {
                const userDoc = await getDoc(doc(db, "users", user.uid));
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    window.userData = userData;
                    updateUserProfile(user, userData);
                    
                    // Set user display name if available
                    if (userData.firstName && userData.lastName) {
                        currentUser.displayName = `${userData.firstName} ${userData.lastName}`;
                    } else if (userData.username) {
                        currentUser.displayName = userData.username;
                    }
                } else {
                    updateUserProfile(user, {});
                }
                
                // Load forum data
                await loadExperts();
                await loadPosts();
            } catch (error) {
                console.error('Error loading user data:', error);
                updateUserProfile(user, {});
                showError("Failed to load forum data. Please try again.");
            }
        } else {
            console.log('User is not signed in');
            window.location.href = 'signin.html';
        }
    });

    function updateUserProfile(user, userData) {
        const userNameElement = document.querySelector('.user-name');
        const userRoleElement = document.querySelector('.user-role');

        const displayName = userData.firstName && userData.lastName 
            ? `${userData.firstName} ${userData.lastName}`
            : userData.username 
            ? userData.username
            : userData.displayName || user.displayName || user.email.split('@')[0] || 'User';

        if (userNameElement) userNameElement.textContent = displayName;
        if (userRoleElement) userRoleElement.textContent = userData.bio || 'Farmer';

        const avatarSrc = userData.imageBase64 || userData.picture || userData.photoURL || 'images/user-avatar.jpg';
        const avatars = document.querySelectorAll('.user-avatar');
        avatars.forEach(img => {
            if (img) {
                img.src = avatarSrc;
                img.onerror = () => { img.src = 'images/default-avatar.png'; };
            }
        });

        window.userData = userData;
    }

    if (window.__sidebarLoaded) {
        if (window.userData) updateUserProfile(window.currentUser, window.userData);
    } else {
        window.addEventListener('sidebar:loaded', () => {
            if (window.currentUser) updateUserProfile(window.currentUser, window.userData || {});
        }, { once: true });
    }

    // Load experts from database
    async function loadExperts() {
        try {
            const expertsQuery = query(collection(db, "users"), where("isExpert", "==", true));
            const querySnapshot = await getDocs(expertsQuery);
            
            expertsList = [];
            querySnapshot.forEach((doc) => {
                const expert = doc.data();
                expert.id = doc.id;
                expertsList.push(expert);
            });
            
            // Populate expert selects
            updateExpertSelects();
        } catch (error) {
            console.error("Error loading experts:", error);
        }
    }

    // Update expert dropdowns
    function updateExpertSelects() {
        const expertSelect = document.getElementById('expertSelect');
        const postExpertTags = document.getElementById('postExpertTags');
        
        // Clear existing options
        expertSelect.innerHTML = '';
        postExpertTags.innerHTML = '';
        
        expertsList.forEach(expert => {
            const displayName = expert.firstName && expert.lastName 
                ? `${expert.firstName} ${expert.lastName}` 
                : expert.username || expert.email.split('@')[0];
            
            const option1 = document.createElement('option');
            option1.value = expert.id;
            option1.textContent = displayName;
            expertSelect.appendChild(option1);
            
            const option2 = document.createElement('option');
            option2.value = expert.id;
            option2.textContent = displayName;
            postExpertTags.appendChild(option2);
        });
    }

    // Load posts from database
    async function loadPosts() {
        try {
            const postsContainer = document.getElementById('postsContainer');
            postsContainer.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading discussions...</p>
                </div>
            `;

            console.log("Loading forum posts...");
            
            const postsRef = collection(db, "forumPosts");
            let postsQuery;
            
            // Build query based on filters
            if (currentCategory !== 'all') {
                postsQuery = query(postsRef, where("category", "==", currentCategory), orderBy("timestamp", "desc"));
            } else {
                postsQuery = query(postsRef, orderBy("timestamp", "desc"));
            }
            
            const querySnapshot = await getDocs(postsQuery);
            console.log("Found posts:", querySnapshot.size);
            
            if (querySnapshot.empty) {
                showNoPosts();
                return;
            }
            
            allPosts = [];
            querySnapshot.forEach((doc) => {
                const post = doc.data();
                post.id = doc.id;
                allPosts.push(post);
            });
            
            // Store all posts for filtering
            window.allPosts = allPosts;
            
            // Apply any existing filters
            applyFilters();
            
        } catch (error) {
            console.error("Error loading posts: ", error);
            showError("Unable to load discussion posts. Please try again later.");
        }
    }

    // Show no posts message
    function showNoPosts() {
        const postsContainer = document.getElementById('postsContainer');
        postsContainer.innerHTML = `
            <div class="no-data">
                <i class="fas fa-comments"></i>
                <h3>No Discussions Available</h3>
                <p>Be the first to start a discussion in this category.</p>
                <button class="btn btn-primary" id="createFirstPostBtn">
                    <i class="fas fa-plus"></i> Create First Post
                </button>
            </div>
        `;
        
        document.getElementById('createFirstPostBtn').addEventListener('click', openCreatePostModal);
    }

    // Show error message
    function showError(message) {
        const postsContainer = document.getElementById('postsContainer');
        postsContainer.innerHTML = `
            <div class="error-message">
                <i class="fas fa-exclamation-triangle"></i>
                <h3>Error Loading Discussions</h3>
                <p>${message}</p>
                <button class="btn btn-primary" id="retryBtn" style="margin-top: 15px;">
                    <i class="fas fa-redo"></i> Try Again
                </button>
            </div>
        `;
        
        document.getElementById('retryBtn').addEventListener('click', () => {
            loadPosts();
        });
    }

    // Apply filters to posts
    function applyFilters() {
        const postsContainer = document.getElementById('postsContainer');
        postsContainer.innerHTML = '';
        
        if (!window.allPosts || window.allPosts.length === 0) {
            showNoPosts();
            return;
        }
        
        let filteredPosts = [...window.allPosts];
        
        // Category filter
        if (currentFilters.category !== 'all') {
            filteredPosts = filteredPosts.filter(post => post.category === currentFilters.category);
        }
        
        // Date filter
        if (currentFilters.dateFrom || currentFilters.dateTo) {
            filteredPosts = filteredPosts.filter(post => {
                let postDate;
                try {
                    if (post.timestamp) {
                        postDate = new Date(post.timestamp.toDate());
                    } else {
                        postDate = new Date();
                    }
                } catch (dateError) {
                    postDate = new Date();
                }
                
                if (currentFilters.dateFrom) {
                    const fromDate = new Date(currentFilters.dateFrom);
                    if (postDate < fromDate) return false;
                }
                
                if (currentFilters.dateTo) {
                    const toDate = new Date(currentFilters.dateTo);
                    toDate.setHours(23, 59, 59, 999);
                    if (postDate > toDate) return false;
                }
                
                return true;
            });
        }
        
        // Sort posts
        switch(currentFilters.sort) {
            case 'oldest':
                filteredPosts.sort((a, b) => {
                    const dateA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                    const dateB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                    return dateA - dateB;
                });
                break;
            case 'most-votes':
                filteredPosts.sort((a, b) => {
                    const votesA = (a.upvotes || []).length - (a.downvotes || []).length;
                    const votesB = (b.upvotes || []).length - (b.downvotes || []).length;
                    return votesB - votesA;
                });
                break;
            case 'most-replies':
                filteredPosts.sort((a, b) => {
                    const repliesA = a.replies ? a.replies.length : 0;
                    const repliesB = b.replies ? b.replies.length : 0;
                    return repliesB - repliesA;
                });
                break;
            default: // newest
                // Already sorted by newest by default
                break;
        }
        
        if (filteredPosts.length === 0) {
            postsContainer.innerHTML = `
                <div class="no-data">
                    <i class="fas fa-filter"></i>
                    <h3>No Discussions Match Your Filters</h3>
                    <p>Try adjusting your filter criteria to see more results.</p>
                    <button class="btn btn-primary" id="clearFilterResultsBtn">
                        <i class="fas fa-times"></i> Clear Filters
                    </button>
                </div>
            `;
            
            document.getElementById('clearFilterResultsBtn').addEventListener('click', clearFilters);
        } else {
            filteredPosts.forEach(post => {
                createPostCard(post);
            });
        }
    }

    // Create a post card for each post
    function createPostCard(post) {
        const postsContainer = document.getElementById('postsContainer');
        
        // Format date safely
        let postDate = 'Date not available';
        try {
            if (post.timestamp) {
                postDate = new Date(post.timestamp.toDate()).toLocaleDateString();
            }
        } catch (dateError) {
            console.log("Date parsing error:", dateError);
        }
        
        // Calculate votes
        const upvotesCount = post.upvotes ? post.upvotes.length : 0;
        const downvotesCount = post.downvotes ? post.downvotes.length : 0;
        const totalVotes = upvotesCount - downvotesCount;
        
        // Check if current user has voted
        const userUpvoted = post.upvotes && post.upvotes.includes(currentUser.uid);
        const userDownvoted = post.downvotes && post.downvotes.includes(currentUser.uid);
        
        // Count replies
        const repliesCount = post.replies ? post.replies.length : 0;
        
        const postCard = document.createElement('div');
        postCard.className = 'post-card';
        postCard.setAttribute('data-id', post.id);
        
        postCard.innerHTML = `
            <div class="post-header">
                <div class="post-meta">
                    <div class="post-author">${post.authorName || 'Anonymous'}</div>
                    <div class="post-date">${postDate}</div>
                </div>
                <div class="post-category">
                    <span class="category-tag category-${post.category}">${post.category}</span>
                </div>
            </div>
            <div class="post-body">
                <h3 class="post-title">${post.title}</h3>
                <p class="post-preview">${post.content.length > 150 ? post.content.substring(0, 150) + '...' : post.content}</p>
                ${post.expertTags && post.expertTags.length > 0 ? `
                    <div class="expert-tags">
                        <span>Tagged: </span>
                        ${post.expertTags.map(tag => `<span class="expert-tag">${getExpertName(tag)}</span>`).join('')}
                    </div>
                ` : ''}
            </div>
            <div class="post-footer">
                <div class="post-stats">
                    <div class="stat-item">
                        <i class="fas fa-comments"></i>
                        <span>${repliesCount}</span>
                    </div>
                    <div class="stat-item vote-container">
                        <button class="vote-btn upvote-btn ${userUpvoted ? 'active' : ''}" title="Upvote">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <span class="vote-count">${totalVotes}</span>
                        <button class="vote-btn downvote-btn ${userDownvoted ? 'active' : ''}" title="Downvote">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                </div>
                <div class="post-actions">
                    <button class="action-btn view-details" title="View Discussion">
                        <i class="fas fa-eye"></i> View
                    </button>
                    ${post.authorId === currentUser.uid ? `
                        <button class="action-btn edit-post" title="Edit Post">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="action-btn delete-post" title="Delete Post">
                            <i class="fas fa-trash"></i>
                        </button>
                    ` : ''}
                </div>
            </div>
        `;
        
        postsContainer.appendChild(postCard);
        
        // Add event listeners
        const viewBtn = postCard.querySelector('.view-details');
        viewBtn.addEventListener('click', () => {
            showPostDetails(post);
        });
        
        const upvoteBtn = postCard.querySelector('.upvote-btn');
        const downvoteBtn = postCard.querySelector('.downvote-btn');
        
        upvoteBtn.addEventListener('click', () => {
            handleVote(post.id, 'upvote');
        });
        
        downvoteBtn.addEventListener('click', () => {
            handleVote(post.id, 'downvote');
        });
        
        // Edit and delete buttons (only for post author)
        if (post.authorId === currentUser.uid) {
            const editBtn = postCard.querySelector('.edit-post');
            const deleteBtn = postCard.querySelector('.delete-post');
            
            editBtn.addEventListener('click', () => {
                openEditPostModal(post);
            });
            
            deleteBtn.addEventListener('click', () => {
                deletePost(post.id);
            });
        }
    }

    // Get expert name by ID
    function getExpertName(expertId) {
        const expert = expertsList.find(e => e.id === expertId);
        if (expert) {
            return expert.firstName && expert.lastName 
                ? `${expert.firstName} ${expert.lastName}` 
                : expert.username || 'Unknown Expert';
        }
        return 'Unknown Expert';
    }

    // Handle voting on posts
    async function handleVote(postId, voteType) {
        if (!currentUser) return;
        
        try {
            const postRef = doc(db, "forumPosts", postId);
            const postDoc = await getDoc(postRef);
            
            if (!postDoc.exists()) {
                console.error("Post not found");
                return;
            }
            
            const post = postDoc.data();
            const upvotes = post.upvotes || [];
            const downvotes = post.downvotes || [];
            
            // Remove existing votes from this user
            const newUpvotes = upvotes.filter(id => id !== currentUser.uid);
            const newDownvotes = downvotes.filter(id => id !== currentUser.uid);
            
            // Add new vote
            if (voteType === 'upvote') {
                newUpvotes.push(currentUser.uid);
            } else if (voteType === 'downvote') {
                newDownvotes.push(currentUser.uid);
            }
            
            // Update the post
            await updateDoc(postRef, {
                upvotes: newUpvotes,
                downvotes: newDownvotes
            });
            
            // Reload posts to reflect the change
            loadPosts();
            
        } catch (error) {
            console.error("Error voting on post:", error);
            alert("Failed to register your vote. Please try again.");
        }
    }

    // Show post details with replies
    async function showPostDetails(post) {
        const postsContainer = document.getElementById('postsContainer');
        const detailsPanel = document.getElementById('postDetails');
        
        // Hide posts container and show details
        postsContainer.style.display = 'none';
        detailsPanel.style.display = 'block';
        
        // Store current post ID
        currentPostId = post.id;
        
        // Populate post content
        document.getElementById('detailsTitle').textContent = post.title;
        
        // Format date
        let postDate = 'Date not available';
        try {
            if (post.timestamp) {
                postDate = new Date(post.timestamp.toDate()).toLocaleDateString();
            }
        } catch (dateError) {
            console.log("Date parsing error:", dateError);
        }
        
        // Calculate votes
        const upvotesCount = post.upvotes ? post.upvotes.length : 0;
        const downvotesCount = post.downvotes ? post.downvotes.length : 0;
        const totalVotes = upvotesCount - downvotesCount;
        
        // Check if current user has voted
        const userUpvoted = post.upvotes && post.upvotes.includes(currentUser.uid);
        const userDownvoted = post.downvotes && post.downvotes.includes(currentUser.uid);
        
        const postContent = document.getElementById('postContent');
        postContent.innerHTML = `
            <div class="original-post">
                <div class="post-header">
                    <div class="post-meta">
                        <div class="post-author">${post.authorName || 'Anonymous'}</div>
                        <div class="post-date">${postDate}</div>
                    </div>
                    <div class="post-category">
                        <span class="category-tag category-${post.category}">${post.category}</span>
                    </div>
                </div>
                <div class="post-body">
                    <p>${post.content}</p>
                    ${post.expertTags && post.expertTags.length > 0 ? `
                        <div class="expert-tags">
                            <span>Tagged Experts: </span>
                            ${post.expertTags.map(tag => `<span class="expert-tag">${getExpertName(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                </div>
                <div class="post-footer">
                    <div class="post-stats">
                        <div class="stat-item vote-container">
                            <button class="vote-btn upvote-btn ${userUpvoted ? 'active' : ''}" id="detailUpvoteBtn">
                                <i class="fas fa-chevron-up"></i>
                            </button>
                            <span class="vote-count">${totalVotes}</span>
                            <button class="vote-btn downvote-btn ${userDownvoted ? 'active' : ''}" id="detailDownvoteBtn">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                    </div>
                    ${post.authorId === currentUser.uid ? `
                        <div class="post-actions">
                            <button class="action-btn edit-post" id="detailEditBtn">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button class="action-btn delete-post" id="detailDeleteBtn">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        // Add event listeners for voting in detail view
        document.getElementById('detailUpvoteBtn').addEventListener('click', () => {
            handleVote(post.id, 'upvote');
        });
        
        document.getElementById('detailDownvoteBtn').addEventListener('click', () => {
            handleVote(post.id, 'downvote');
        });
        
        // Edit and delete buttons (only for post author)
        if (post.authorId === currentUser.uid) {
            document.getElementById('detailEditBtn').addEventListener('click', () => {
                openEditPostModal(post);
            });
            
            document.getElementById('detailDeleteBtn').addEventListener('click', () => {
                deletePost(post.id);
            });
        }
        
        // Load replies
        await loadReplies(post.id);
    }

    // Load replies for a post
    async function loadReplies(postId) {
        try {
            const repliesContainer = document.getElementById('repliesContainer');
            repliesContainer.innerHTML = '<div class="loading"><p>Loading replies...</p></div>';
            
            const postRef = doc(db, "forumPosts", postId);
            const postDoc = await getDoc(postRef);
            
            if (!postDoc.exists()) {
                repliesContainer.innerHTML = '<div class="no-data"><p>Post not found</p></div>';
                return;
            }
            
            const post = postDoc.data();
            const replies = post.replies || [];
            
            if (replies.length === 0) {
                repliesContainer.innerHTML = `
                    <div class="no-replies">
                        <i class="fas fa-comments"></i>
                        <p>No replies yet. Be the first to reply!</p>
                    </div>
                `;
                return;
            }
            
            repliesContainer.innerHTML = '<h3>Replies</h3>';
            
            // Sort replies by timestamp (newest first)
            replies.sort((a, b) => {
                const dateA = a.timestamp ? a.timestamp.toDate() : new Date(0);
                const dateB = b.timestamp ? b.timestamp.toDate() : new Date(0);
                return dateB - dateA;
            });
            
            replies.forEach(reply => {
                const replyElement = document.createElement('div');
                replyElement.className = 'reply-item';
                
                // Format date
                let replyDate = 'Date not available';
                try {
                    if (reply.timestamp) {
                        replyDate = new Date(reply.timestamp.toDate()).toLocaleDateString();
                    }
                } catch (dateError) {
                    console.log("Date parsing error:", dateError);
                }
                
                replyElement.innerHTML = `
                    <div class="reply-header">
                        <div class="reply-author">${reply.authorName || 'Anonymous'}</div>
                        <div class="reply-date">${replyDate}</div>
                    </div>
                    <div class="reply-content">${reply.content}</div>
                    ${reply.expertTags && reply.expertTags.length > 0 ? `
                        <div class="expert-tags">
                            <span>Tagged: </span>
                            ${reply.expertTags.map(tag => `<span class="expert-tag">${getExpertName(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                `;
                
                repliesContainer.appendChild(replyElement);
            });
            
        } catch (error) {
            console.error("Error loading replies:", error);
            document.getElementById('repliesContainer').innerHTML = `
                <div class="error-message">
                    <p>Failed to load replies. Please try again.</p>
                </div>
            `;
        }
    }

    // Create a new post
    async function createNewPost() {
        const title = document.getElementById('postTitle').value.trim();
        const content = document.getElementById('postContentInput').value.trim();
        const category = document.getElementById('postCategory').value;
        const expertTags = Array.from(document.getElementById('postExpertTags').selectedOptions).map(option => option.value);
        
        if (!title || !content) {
            alert('Please provide both a title and content for your post.');
            return;
        }
        
        try {
            const newPost = {
                title,
                content,
                category,
                authorId: currentUser.uid,
                authorName: currentUser.displayName,
                timestamp: serverTimestamp(),
                upvotes: [],
                downvotes: [],
                replies: [],
                expertTags
            };
            
            await addDoc(collection(db, "forumPosts"), newPost);
            
            // Close modal and reload posts
            closeCreatePostModal();
            loadPosts();
            
        } catch (error) {
            console.error("Error creating post:", error);
            alert("Failed to create post. Please try again.");
        }
    }

    // Add reply to a post
    async function addReply() {
        const replyText = document.getElementById('replyText').value.trim();
        const expertTags = Array.from(document.getElementById('expertSelect').selectedOptions).map(option => option.value);
        
        if (!replyText) {
            alert('Please enter a reply.');
            return;
        }
        
        if (!currentPostId) {
            alert('No post selected.');
            return;
        }
        
        try {
            const postRef = doc(db, "forumPosts", currentPostId);
            const postDoc = await getDoc(postRef);
            
            if (!postDoc.exists()) {
                alert('Post not found.');
                return;
            }
            
            const newReply = {
                content: replyText,
                authorId: currentUser.uid,
                authorName: currentUser.displayName,
                timestamp: serverTimestamp(),
                expertTags
            };
            
            await updateDoc(postRef, {
                replies: arrayUnion(newReply)
            });
            
            // Clear reply textarea
            document.getElementById('replyText').value = '';
            
            // Reload replies
            await loadReplies(currentPostId);
            
        } catch (error) {
            console.error("Error adding reply:", error);
            alert("Failed to post reply. Please try again.");
        }
    }

    // Open create post modal
    function openCreatePostModal() {
        document.getElementById('createPostModal').style.display = 'flex';
    }

    // Close create post modal
    function closeCreatePostModal() {
        document.getElementById('createPostModal').style.display = 'none';
        // Reset form
        document.getElementById('postTitle').value = '';
        document.getElementById('postContentInput').value = '';
        document.getElementById('postCategory').value = 'diseases';
        document.getElementById('postExpertTags').selectedIndex = -1;
    }

    // Open edit post modal
    function openEditPostModal(post) {
        document.getElementById('editPostTitle').value = post.title;
        document.getElementById('editPostContent').value = post.content;
        document.getElementById('editPostModal').style.display = 'flex';
        
        // Store the post ID for saving
        window.editingPostId = post.id;
    }

    // Close edit post modal
    function closeEditPostModal() {
        document.getElementById('editPostModal').style.display = 'none';
        window.editingPostId = null;
    }

    // Save edited post
    async function saveEditedPost() {
        if (!window.editingPostId) return;
        
        const title = document.getElementById('editPostTitle').value.trim();
        const content = document.getElementById('editPostContent').value.trim();
        
        if (!title || !content) {
            alert('Please provide both a title and content for your post.');
            return;
        }
        
        try {
            const postRef = doc(db, "forumPosts", window.editingPostId);
            await updateDoc(postRef, {
                title,
                content,
                lastEdited: serverTimestamp()
            });
            
            closeEditPostModal();
            loadPosts();
            
            // If in detail view, update it too
            if (currentPostId === window.editingPostId) {
                const postDoc = await getDoc(postRef);
                if (postDoc.exists()) {
                    showPostDetails({...postDoc.data(), id: window.editingPostId});
                }
            }
            
        } catch (error) {
            console.error("Error editing post:", error);
            alert("Failed to update post. Please try again.");
        }
    }

    // Delete a post
    async function deletePost(postId) {
        if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
            return;
        }
        
        try {
            await deleteDoc(doc(db, "forumPosts", postId));
            
            // If in detail view, go back to forum
            if (currentPostId === postId) {
                closePostDetails();
            }
            
            loadPosts();
            
        } catch (error) {
            console.error("Error deleting post:", error);
            alert("Failed to delete post. Please try again.");
        }
    }

    // Open filter modal
    function openFilterModal() {
        document.getElementById('filterModal').style.display = 'flex';
    }

    // Close filter modal
    function closeFilterModal() {
        document.getElementById('filterModal').style.display = 'none';
    }

    // Clear all filters
    function clearFilters() {
        currentFilters = {
            category: 'all',
            sort: 'newest',
            dateFrom: '',
            dateTo: ''
        };
        
        // Reset filter inputs
        document.getElementById('categoryFilter').value = 'all';
        document.getElementById('sortFilter').value = 'newest';
        document.getElementById('dateFrom').value = '';
        document.getElementById('dateTo').value = '';
        
        applyFilters();
        closeFilterModal();
    }

    // Close post details view
    function closePostDetails() {
        const postsContainer = document.getElementById('postsContainer');
        const detailsPanel = document.getElementById('postDetails');
        
        detailsPanel.style.display = 'none';
        postsContainer.style.display = 'block';
        currentPostId = null;
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function() {
        // Tab click events
        document.querySelectorAll('.tab-btn').forEach(tab => {
            tab.addEventListener('click', function() {
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Update category and reload posts
                currentCategory = this.dataset.category;
                loadPosts();
            });
        });
        
        // Create post button
        document.getElementById('createPostBtn').addEventListener('click', openCreatePostModal);
        
        // Filter button
        document.getElementById('filterBtn').addEventListener('click', openFilterModal);
        
        // Apply filters button
        document.getElementById('applyFiltersBtn').addEventListener('click', () => {
            currentFilters.category = document.getElementById('categoryFilter').value;
            currentFilters.sort = document.getElementById('sortFilter').value;
            currentFilters.dateFrom = document.getElementById('dateFrom').value;
            currentFilters.dateTo = document.getElementById('dateTo').value;
            
            applyFilters();
            closeFilterModal();
        });
        
        // Clear filters button
        document.getElementById('clearFiltersBtn').addEventListener('click', clearFilters);
        
        // Close filter modal
        document.getElementById('closeFilterBtn').addEventListener('click', closeFilterModal);
        
        // Create post modal
        document.getElementById('closeCreateModalBtn').addEventListener('click', closeCreatePostModal);
        document.getElementById('cancelPostBtn').addEventListener('click', closeCreatePostModal);
        document.getElementById('submitPostBtn').addEventListener('click', createNewPost);
        
        // Edit post modal
        document.getElementById('closeEditModalBtn').addEventListener('click', closeEditPostModal);
        document.getElementById('cancelEditBtn').addEventListener('click', closeEditPostModal);
        document.getElementById('saveEditBtn').addEventListener('click', saveEditedPost);
        
        // Close details button
        document.getElementById('closeDetailsBtn').addEventListener('click', closePostDetails);
        
        // Submit reply button
        document.getElementById('submitReplyBtn').addEventListener('click', addReply);
        
        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const postCards = document.querySelectorAll('.post-card');
            
            postCards.forEach(card => {
                const title = card.querySelector('.post-title').textContent.toLowerCase();
                const preview = card.querySelector('.post-preview').textContent.toLowerCase();
                const author = card.querySelector('.post-author').textContent.toLowerCase();
                const category = card.querySelector('.category-tag').textContent.toLowerCase();
                
                if (title.includes(searchTerm) || preview.includes(searchTerm) || 
                    author.includes(searchTerm) || category.includes(searchTerm)) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        });
        
        // Close modals when clicking outside
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        });
        
        // Logout functionality
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', function(e) {
                e.preventDefault();
                signOut(auth).then(() => {
                    window.location.href = 'signin.html';
                }).catch((error) => {
                    console.error('Logout error:', error);
                });
            });
        }
    });
    </script>
</body>
</html>